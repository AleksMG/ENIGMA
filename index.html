<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–§–í–ö –®–∏—Ñ—Ä–∞—Ç–æ—Ä</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        textarea, input, button { width: 100%; padding: 10px; margin: 5px 0; }
        button { background: #4CAF50; color: white; border: none; cursor: pointer; }
        button:hover { background: #45a049; }
        .container { display: flex; gap: 20px; }
        .box { flex: 1; }
    </style>
</head>
<body>
    <h1>üîê –§—Ä–∞–∫—Ç–∞–ª—å–Ω–æ-–í—Ä–µ–º–µ–Ω–Ω–æ–π –ö—Ä–∏–ø—Ç–æ—à–∏—Ñ—Ä–∞—Ç–æ—Ä</h1>
    
    <div class="container">
        <div class="box">
            <h2>–®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h2>
            <textarea id="plaintext" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..."></textarea>
            <input type="text" id="seed" placeholder="–°–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á (–º–∏–Ω–∏–º—É–º 10 —Å–∏–º–≤–æ–ª–æ–≤)">
            <button onclick="encrypt()">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <textarea id="encrypted" readonly placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç..."></textarea>
        </div>
        
        <div class="box">
            <h2>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞</h2>
            <textarea id="ciphertext" placeholder="–í–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç..."></textarea>
            <input type="text" id="decryptSeed" placeholder="–¢–æ—Ç –∂–µ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á">
            <button onclick="decrypt()">–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
            <textarea id="decrypted" readonly placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç..."></textarea>
        </div>
    </div>

    <script>
        // ===== –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ—Ä–∞–∫—Ç–∞–ª—å–Ω–æ–≥–æ –∫–ª—é—á–∞ =====
        function generateFractalKey(seed, length) {
            let key = [];
            let prev = seed.split('').map(Number);
            
            while (key.length < length) {
                let next = [];
                for (let i = 0; i < prev.length; i++) {
                    next.push((prev[i] * (i + 1) + (prev[i - 1] || 0)) % 10);
                }
                key = key.concat(next);
                prev = next;
            }
            
            return key.slice(0, length);
        }

        // ===== –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Å–º–µ—â–µ–Ω–∏—è =====
        function applyTimeOffset(key) {
            const now = new Date();
            const timeHash = now.getHours() * now.getMinutes() * now.getSeconds();
            return key.map((val, i) => (val + timeHash.toString().charCodeAt(i % 6)) % 256);
        }

        // ===== –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ =====
        function encrypt() {
            const text = document.getElementById('plaintext').value;
            const seed = document.getElementById('seed').value;
            
            if (!seed || seed.length < 10) {
                alert("–ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 10 —Å–∏–º–≤–æ–ª–æ–≤!");
                return;
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞
            const fractalKey = generateFractalKey(seed, text.length * 2);
            const timeKey = applyTimeOffset(fractalKey);
            
            // –ü–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ + XOR
            let encrypted = '';
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                const keyPart = timeKey[i % timeKey.length];
                encrypted += String.fromCharCode(charCode ^ keyPart);
            }
            
            document.getElementById('encrypted').value = btoa(encrypted); // Base64 –¥–ª—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏
        }

        // ===== –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ =====
        function decrypt() {
            const ciphertext = atob(document.getElementById('ciphertext').value);
            const seed = document.getElementById('decryptSeed').value;
            
            if (!seed || seed.length < 10) {
                alert("–ù—É–∂–µ–Ω —Ç–æ—Ç –∂–µ –∫–ª—é—á, —á—Ç–æ –∏ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏!");
                return;
            }
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ–≥–æ –∂–µ –∫–ª—é—á–∞
            const fractalKey = generateFractalKey(seed, ciphertext.length * 2);
            const timeKey = applyTimeOffset(fractalKey);
            
            // –û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
            let decrypted = '';
            for (let i = 0; i < ciphertext.length; i++) {
                const charCode = ciphertext.charCodeAt(i);
                const keyPart = timeKey[i % timeKey.length];
                decrypted += String.fromCharCode(charCode ^ keyPart);
            }
            
            document.getElementById('decrypted').value = decrypted;
        }
    </script>
</body>
</html>
