<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM ARMOR PRO</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a12;
            color: #d1f7ff;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        .panel {
            background: #1a1a3a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            border: 1px solid #ff2a6d;
        }
        h1, h2 {
            color: #ff2a6d;
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.2rem;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255,42,109,0.5);
        }
        textarea, input {
            width: 100%;
            background: #2d2d6b;
            color: #d1f7ff;
            border: 1px solid #ff2a6d;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-family: inherit;
            font-size: 16px;
        }
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        button {
            background: linear-gradient(135deg, #ff2a6d, #ff5e8a);
            color: white;
            border: none;
            padding: 14px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            font-size: 16px;
            margin: 10px 0;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,42,109,0.4);
        }
        .status {
            text-align: center;
            margin: 15px 0;
            font-size: 14px;
            color: #5dffa7;
        }
        .security-info {
            font-size: 12px;
            color: #8b8bff;
            margin-top: 30px;
            padding: 10px;
            border-top: 1px dashed #444477;
        }
    </style>
</head>
<body>
    <h1>QUANTUM ARMOR PRO</h1>
    <div class="status" id="status">Система готова к работе</div>
    
    <div class="container">
        <div class="panel">
            <h2>ШИФРОВАНИЕ</h2>
            <textarea id="plaintext" placeholder="Введите текст для шифрования..."></textarea>
            <input type="password" id="key" placeholder="Введите криптографический ключ (рекомендуется 32+ символа)">
            <button onclick="encrypt()">ЗАШИФРОВАТЬ</button>
            <textarea id="ciphertext" placeholder="Результат шифрования..." readonly></textarea>
        </div>

        <div class="panel">
            <h2>РАСШИФРОВАНИЕ</h2>
            <textarea id="encrypted" placeholder="Введите зашифрованные данные..."></textarea>
            <input type="password" id="decryptKey" placeholder="Введите тот же криптографический ключ">
            <button onclick="decrypt()">РАСШИФРОВАТЬ</button>
            <textarea id="decrypted" placeholder="Результат расшифровки..." readonly></textarea>
        </div>
    </div>

    <div class="security-info">
        <strong>Безопасность:</strong> Алгоритм использует 256-битное шифрование с 24 раундами преобразования, 
        динамическими S-блоками и защитой от атак по времени. Не хранит и не передает ключи.
    </div>

    <script>
        class QuantumArmorPro {
            constructor() {
                this.ivLength = 16; // 128-bit вектор инициализации
                this.macLength = 32; // 256-bit аутентификационный код
                this.rounds = 24; // Увеличенное число раундов
                this.saltLength = 32; // 256-bit соль для PBKDF2
                this.minKeyLength = 8; // Минимальная длина ключа
            }

            // Инициализация системы
            async init() {
                await this.generateSBoxes();
                document.getElementById('status').textContent = "Система инициализирована";
            }

            // Генерация динамических S-блоков
            async generateSBoxes() {
                this.sbox = new Uint8Array(256);
                this.invSbox = new Uint8Array(256);
                
                // Заполнение на основе SHA-512 от случайного зерна
                const seed = crypto.getRandomValues(new Uint8Array(64));
                const hash = await crypto.subtle.digest('SHA-512', seed);
                const hashBytes = new Uint8Array(hash);
                
                // Построение S-блоков
                for (let i = 0; i < 256; i++) {
                    this.sbox[i] = hashBytes[i % 64] ^ hashBytes[(i + 37) % 64];
                    this.sbox[i] = (this.sbox[i] * 16777619) & 0xff;
                    this.invSbox[this.sbox[i]] = i;
                }
            }

            // Основная функция шифрования
            async encrypt(plaintext, key) {
                try {
                    if (!plaintext || !key) throw new Error("Текст и ключ обязательны");
                    if (key.length < this.minKeyLength) throw new Error(`Ключ должен быть не менее ${this.minKeyLength} символов`);
                    
                    document.getElementById('status').textContent = "Шифрование...";
                    
                    // Генерация IV и соли
                    const iv = crypto.getRandomValues(new Uint8Array(this.ivLength));
                    const salt = crypto.getRandomValues(new Uint8Array(this.saltLength));
                    
                    // Преобразование текста в байты
                    const textBytes = new TextEncoder().encode(plaintext);
                    
                    // Генерация ключевого материала
                    const keyMaterial = await this.deriveKey(key, salt, textBytes.length * 2 + 64);
                    
                    // Шифрование
                    const ciphertext = await this.processData(iv, textBytes, keyMaterial, true);
                    
                    // Генерация MAC
                    const mac = await this.generateHMAC(iv, ciphertext, keyMaterial);
                    
                    // Формирование итогового сообщения: salt + iv + ciphertext + mac
                    const result = new Uint8Array([...salt, ...iv, ...ciphertext, ...mac]);
                    
                    document.getElementById('status').textContent = "Шифрование завершено";
                    return this.bytesToBase64(result);
                } catch (e) {
                    document.getElementById('status').textContent = "Ошибка шифрования";
                    throw e;
                }
            }

            // Основная функция расшифровки
            async decrypt(encryptedData, key) {
                try {
                    if (!encryptedData || !key) throw new Error("Данные и ключ обязательны");
                    
                    document.getElementById('status').textContent = "Расшифровка...";
                    
                    // Декодирование из Base64
                    const data = this.base64ToBytes(encryptedData);
                    
                    // Проверка минимальной длины
                    if (data.length < this.saltLength + this.ivLength + this.macLength) {
                        throw new Error("Неверный формат данных");
                    }
                    
                    // Извлечение компонентов
                    const salt = data.slice(0, this.saltLength);
                    const iv = data.slice(this.saltLength, this.saltLength + this.ivLength);
                    const ciphertext = data.slice(this.saltLength + this.ivLength, data.length - this.macLength);
                    const receivedMac = data.slice(data.length - this.macLength);
                    
                    // Генерация ключевого материала
                    const keyMaterial = await this.deriveKey(key, salt, ciphertext.length * 2 + 64);
                    
                    // Проверка MAC
                    const computedMac = await this.generateHMAC(iv, ciphertext, keyMaterial);
                    if (!this.constantTimeCompare(receivedMac, computedMac)) {
                        throw new Error("Неверный ключ или поврежденные данные");
                    }
                    
                    // Расшифровка
                    const plaintextBytes = await this.processData(iv, ciphertext, keyMaterial, false);
                    
                    document.getElementById('status').textContent = "Расшифровка завершена";
                    return new TextDecoder().decode(plaintextBytes);
                } catch (e) {
                    document.getElementById('status').textContent = "Ошибка расшифровки";
                    throw e;
                }
            }

            // Обработка данных (шифрование/расшифровка)
            async processData(iv, data, keyMaterial, encrypt) {
                const result = new Uint8Array(data.length);
                const blockSize = 64; // Размер блока для обработки
                
                // Обработка по блокам
                for (let blockStart = 0; blockStart < data.length; blockStart += blockSize) {
                    const blockEnd = Math.min(blockStart + blockSize, data.length);
                    const block = data.slice(blockStart, blockEnd);
                    
                    // Добавление IV к блоку
                    const processedBlock = new Uint8Array([...iv, ...block]);
                    
                    // Применение раундов преобразования
                    if (encrypt) {
                        this.encryptionRounds(processedBlock, keyMaterial);
                    } else {
                        this.decryptionRounds(processedBlock, keyMaterial);
                    }
                    
                    // Сохранение результата (без IV)
                    result.set(processedBlock.slice(iv.length), blockStart);
                    
                    // Обновление IV для следующего блока
                    iv = processedBlock.slice(processedBlock.length - iv.length);
                }
                
                return result;
            }

            // Раунды шифрования
            encryptionRounds(data, keyMaterial) {
                for (let round = 0; round < this.rounds; round++) {
                    // Фаза замещения
                    this.substituteBytes(data, keyMaterial, round);
                    
                    // Фаза перемешивания
                    this.mixColumns(data, keyMaterial, round);
                    
                    // Фаза перестановки
                    this.permuteBytes(data, keyMaterial, round);
                    
                    // Добавление ключевого материала
                    this.addRoundKey(data, keyMaterial, round);
                }
            }

            // Раунды расшифровки
            decryptionRounds(data, keyMaterial) {
                for (let round = this.rounds - 1; round >= 0; round--) {
                    // Обратное добавление ключевого материала
                    this.addRoundKey(data, keyMaterial, round, true);
                    
                    // Обратная перестановка
                    this.permuteBytes(data, keyMaterial, round, true);
                    
                    // Обратное перемешивание
                    this.mixColumns(data, keyMaterial, round, true);
                    
                    // Обратное замещение
                    this.substituteBytes(data, keyMaterial, round, true);
                }
            }

            // Функции преобразований
            substituteBytes(data, keyMaterial, round, inverse = false) {
                const sbox = inverse ? this.invSbox : this.sbox;
                for (let i = 0; i < data.length; i++) {
                    const keyIndex = (i + round * 17) % keyMaterial.length;
                    data[i] = sbox[data[i] ^ keyMaterial[keyIndex]];
                }
            }

            mixColumns(data, keyMaterial, round, inverse = false) {
                const size = Math.floor(Math.sqrt(data.length)) || 4;
                for (let col = 0; col < size; col++) {
                    const column = new Uint8Array(size);
                    for (let row = 0; row < size; row++) {
                        column[row] = data[(row * size + col) % data.length];
                    }
                    
                    // Матричное преобразование
                    const mixed = this.matrixTransform(column, keyMaterial, round, inverse);
                    
                    // Обратная запись
                    for (let row = 0; row < size; row++) {
                        data[(row * size + col) % data.length] = mixed[row];
                    }
                }
            }

            matrixTransform(column, keyMaterial, round, inverse) {
                const result = new Uint8Array(column.length);
                const matrix = this.generateMatrix(keyMaterial, round, column.length);
                
                for (let i = 0; i < column.length; i++) {
                    let val = 0;
                    for (let j = 0; j < column.length; j++) {
                        if (inverse) {
                            val ^= this.gfMultiply(matrix[j][i], column[j]);
                        } else {
                            val ^= this.gfMultiply(matrix[i][j], column[j]);
                        }
                    }
                    result[i] = val;
                }
                
                return result;
            }

            gfMultiply(a, b) {
                let p = 0;
                for (let i = 0; i < 8; i++) {
                    if (b & 1) p ^= a;
                    const hi = a & 0x80;
                    a <<= 1;
                    if (hi) a ^= 0x1b; // Полином AES
                    b >>= 1;
                }
                return p & 0xff;
            }

            generateMatrix(keyMaterial, round, size) {
                const matrix = Array.from({length: size}, () => new Uint8Array(size));
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const keyIndex = (i * size + j + round * 11) % keyMaterial.length;
                        matrix[i][j] = keyMaterial[keyIndex] || 1;
                    }
                }
                return matrix;
            }

            permuteBytes(data, keyMaterial, round, inverse = false) {
                const temp = new Uint8Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    const newPos = inverse ? 
                        (i * 9 - keyMaterial[(i + round) % keyMaterial.length]) % data.length :
                        (i * 5 + keyMaterial[(i + round) % keyMaterial.length]) % data.length;
                    temp[(newPos + data.length) % data.length] = data[i];
                }
                data.set(temp);
            }

            addRoundKey(data, keyMaterial, round, inverse = false) {
                for (let i = 0; i < data.length; i++) {
                    const keyIndex = (i + round * 23) % keyMaterial.length;
                    if (inverse) {
                        data[i] ^= keyMaterial[keyIndex];
                    } else {
                        data[i] ^= keyMaterial[keyIndex] ^ round;
                    }
                }
            }

            // Вспомогательные криптографические функции
            async deriveKey(password, salt, length) {
                const iterations = 200000;
                const encoder = new TextEncoder();
                
                // Первая стадия: PBKDF2
                const keyMaterial = await crypto.subtle.importKey(
                    'raw', encoder.encode(password),
                    {name: 'PBKDF2'}, false, ['deriveBits']
                );
                
                const derivedBits = await crypto.subtle.deriveBits(
                    {name: 'PBKDF2', salt, iterations, hash: 'SHA-512'},
                    keyMaterial,
                    Math.max(512, length * 8)
                );
                
                // Вторая стадия: HKDF
                const hkdfKey = await crypto.subtle.importKey(
                    'raw', new Uint8Array(derivedBits),
                    {name: 'HMAC', hash: 'SHA-512'}, false, ['sign']
                );
                
                const hkdf = await crypto.subtle.sign(
                    'HMAC', hkdfKey,
                    encoder.encode('QUANTUM_ARMOR_KEY_DERIVATION')
                );
                
                return new Uint8Array(hkdf).slice(0, length);
            }

            async generateHMAC(iv, data, keyMaterial) {
                const hmacKey = await crypto.subtle.importKey(
                    'raw', keyMaterial.slice(0, 64),
                    {name: 'HMAC', hash: 'SHA-256'}, false, ['sign']
                );
                
                const macData = new Uint8Array([...iv, ...data]);
                const mac = await crypto.subtle.sign('HMAC', hmacKey, macData);
                return new Uint8Array(mac);
            }

            constantTimeCompare(a, b) {
                if (a.length !== b.length) return false;
                let result = 0;
                for (let i = 0; i < a.length; i++) {
                    result |= a[i] ^ b[i];
                }
                return result === 0;
            }

            // Утилиты преобразования
            bytesToBase64(bytes) {
                return btoa(String.fromCharCode(...bytes));
            }

            base64ToBytes(base64) {
                return new Uint8Array([...atob(base64)].map(c => c.charCodeAt(0)));
            }
        }

        // Инициализация системы
        const cryptoSystem = new QuantumArmorPro();
        cryptoSystem.init().catch(console.error);

        // Обработчики интерфейса
        async function encrypt() {
            try {
                const plaintext = document.getElementById('plaintext').value;
                const key = document.getElementById('key').value;
                const ciphertext = await cryptoSystem.encrypt(plaintext, key);
                document.getElementById('ciphertext').value = ciphertext;
            } catch (e) {
                document.getElementById('status').textContent = `Ошибка: ${e.message}`;
                document.getElementById('ciphertext').value = '';
            }
        }

        async function decrypt() {
            try {
                const encrypted = document.getElementById('encrypted').value;
                const key = document.getElementById('decryptKey').value;
                const decrypted = await cryptoSystem.decrypt(encrypted, key);
                document.getElementById('decrypted').value = decrypted;
            } catch (e) {
                document.getElementById('status').textContent = `Ошибка: ${e.message}`;
                document.getElementById('decrypted').value = '';
            }
        }
    </script>
</body>
</html>
