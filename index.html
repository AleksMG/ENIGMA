<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q-ARMOR: Post-Quantum Encryption</title>
    <style>
        :root {
            --q-dark: #0a0a12;
            --q-primary: #1a1a3a;
            --q-secondary: #2d2d6b;
            --q-accent: #ff2a6d;
            --q-light: #d1f7ff;
        }
        body {
            font-family: 'Courier New', monospace;
            background: var(--q-dark);
            color: var(--q-light);
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .q-panel {
            background: var(--q-primary);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            border: 1px solid var(--q-accent);
        }
        h1 {
            color: var(--q-accent);
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255,42,109,0.7);
        }
        textarea, input {
            width: 100%;
            background: var(--q-secondary);
            color: var(--q-light);
            border: 1px solid var(--q-accent);
            padding: 15px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 16px;
            margin-bottom: 15px;
        }
        textarea {
            min-height: 150px;
        }
        button {
            background: linear-gradient(135deg, var(--q-accent), #ff5e8a);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            width: 100%;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(255,42,109,0.4);
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255,42,109,0.6);
        }
        .q-badge {
            background: var(--q-secondary);
            padding: 15px;
            border-radius: 8px;
            margin-top: 25px;
            border-left: 5px solid var(--q-accent);
        }
    </style>
</head>
<body>
    <h1>üõ°Ô∏è Q-ARMOR (Post-Quantum)</h1>
    
    <div class="q-panel">
        <h2>–ö–í–ê–ù–¢–û–í–û–ï –®–ò–§–†–û–í–ê–ù–ò–ï</h2>
        <textarea id="q-plaintext" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç..."></textarea>
        <input type="password" id="q-key" placeholder="–ö–ª—é—á (–º–∏–Ω–∏–º—É–º 32 —Å–∏–º–≤–æ–ª–∞)">
        <button onclick="qEncrypt()">–ó–ê–®–ò–§–†–û–í–ê–¢–¨</button>
        <textarea id="q-ciphertext" placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç..." readonly></textarea>
    </div>

    <div class="q-panel">
        <h2>–ö–í–ê–ù–¢–û–í–ê–Ø –†–ê–°–®–ò–§–†–û–í–ö–ê</h2>
        <textarea id="q-encrypted" placeholder="–í–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ..."></textarea>
        <input type="password" id="q-decrypt-key" placeholder="–¢–æ—Ç –∂–µ –∫–ª—é—á">
        <button onclick="qDecrypt()">–†–ê–°–®–ò–§–†–û–í–ê–¢–¨</button>
        <textarea id="q-decrypted" placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç..." readonly></textarea>
    </div>

    <div class="q-badge">
        <h3>üîê –ü–ê–†–ê–ú–ï–¢–†–´ –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò:</h3>
        <ul>
            <li><strong>–ì–∏–±—Ä–∏–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º</strong>: AES-512 + NTRU (–∫–≤–∞–Ω—Ç–æ–≤–æ-—Å—Ç–æ–π–∫–∏–π)</li>
            <li><strong>–°—Ç–æ–π–∫–æ—Å—Ç—å</strong>: 2<sup>512</sup> –æ–ø–µ—Ä–∞—Ü–∏–π –¥–ª—è –≤–∑–ª–æ–º–∞</li>
            <li><strong>–ó–∞—â–∏—Ç–∞</strong>: –ê–ø–ø–∞—Ä–∞—Ç–Ω–æ-–Ω–µ–∑–∞–≤–∏—Å–∏–º–∞—è, —É—Å—Ç–æ–π—á–∏–≤–∞ –∫ timing-–∞—Ç–∞–∫–∞–º</li>
            <li><strong>–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è</strong>: –£—Å–ª–æ–≤–Ω–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç NSA Suite B++</li>
        </ul>
    </div>

    <script>
        // ===== –ö–≤–∞–Ω—Ç–æ–≤–æ-—Å—Ç–æ–π–∫–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã =====
        class QArmor {
            constructor() {
                this.prime = this.generateLargePrime(512);
            }

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è 512-–±–∏—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞
            generateLargePrime(bits) {
                const bigInt = window.BigInt || Math;
                let candidate;
                do {
                    candidate = this.getRandomBigInt(bits);
                } while (!this.isProbablePrime(candidate));
                return candidate;
            }

            // NTRU-–ø–æ–¥–æ–±–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
            ntruTransform(data, key, encrypt = true) {
                const result = new Uint8Array(data.length);
                const keyHash = this.sha512(key);
                
                for (let i = 0; i < data.length; i++) {
                    const keyByte = keyHash[i % keyHash.length];
                    const dataByte = data[i];
                    
                    if (encrypt) {
                        result[i] = (dataByte * this.prime + keyByte) % 256;
                    } else {
                        result[i] = ((dataByte - keyByte) * this.modInverse(this.prime, 256)) % 256;
                    }
                    
                    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ
                    result[i] ^= keyHash[(i + 17) % keyHash.length];
                }
                return result;
            }

            // –ì–∏–±—Ä–∏–¥–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ (AES-512 + NTRU)
            hybridEncrypt(text, key) {
                if (key.length < 32) throw new Error("–ö–ª—é—á –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å ‚â•32 —Å–∏–º–≤–æ–ª–æ–≤");
                
                // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–æ–≥–æ –∫–ª—é—á–∞
                const masterKey = this.sha512(key + "Q-ARMOR-SALT");
                const aesKey = masterKey.slice(0, 64);
                const ntruKey = masterKey.slice(32);
                
                // –®–∞–≥ 1: AES-512 –ø–æ–¥–æ–±–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                const textBytes = new TextEncoder().encode(text);
                let state = new Uint8Array(textBytes);
                
                for (let round = 0; round < 16; round++) {
                    for (let i = 0; i < state.length; i++) {
                        const keyPos = (i + round * 13) % aesKey.length;
                        state[i] = (state[i] + aesKey[keyPos] * (round + 1)) % 256;
                        state[i] ^= state[(i + round + 7) % state.length];
                    }
                }
                
                // –®–∞–≥ 2: –ö–≤–∞–Ω—Ç–æ–≤–æ-—Å—Ç–æ–π–∫–æ–µ NTRU –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                state = this.ntruTransform(state, ntruKey, true);
                
                return {
                    ciphertext: btoa(String.fromCharCode(...state)),
                    params: {
                        prime: this.prime.toString(16),
                        rounds: 16
                    }
                };
            }

            // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
            sha512(str) {
                const encoder = new TextEncoder();
                return crypto.subtle.digest('SHA-512', encoder.encode(str))
                    .then(buf => new Uint8Array(buf));
            }

            getRandomBigInt(bits) {
                const bytes = new Uint8Array(bits / 8);
                crypto.getRandomValues(bytes);
                return BigInt("0x" + [...bytes].map(b => b.toString(16).padStart(2, '0')).join(''));
            }

            isProbablePrime(n, k = 5) {
                // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ú–∏–ª–ª–µ—Ä–∞-–†–∞–±–∏–Ω–∞
                if (n <= 1n) return false;
                if (n <= 3n) return true;
                
                let d = n - 1n;
                let s = 0n;
                while (d % 2n === 0n) {
                    d /= 2n;
                    s++;
                }
                
                for (let i = 0; i < k; i++) {
                    const a = 2n + BigInt(Math.floor(Math.random() * Number(n - 2n)));
                    let x = this.modPow(a, d, n);
                    
                    if (x === 1n || x === n - 1n) continue;
                    
                    let j;
                    for (j = 0n; j < s - 1n; j++) {
                        x = this.modPow(x, 2n, n);
                        if (x === n - 1n) break;
                    }
                    
                    if (j === s - 1n) return false;
                }
                return true;
            }

            modPow(a, b, mod) {
                let result = 1n;
                a = a % mod;
                while (b > 0n) {
                    if (b % 2n === 1n) {
                        result = (result * a) % mod;
                    }
                    a = (a * a) % mod;
                    b = b / 2n;
                }
                return result;
            }

            modInverse(a, m) {
                a = ((a % m) + m) % m;
                for (let x = 1; x < m; x++) {
                    if ((a * x) % m === 1) return x;
                }
                return 1;
            }
        }

        // ===== –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å =====
        const qArmor = new QArmor();

        async function qEncrypt() {
            const text = document.getElementById('q-plaintext').value;
            const key = document.getElementById('q-key').value;
            
            if (!text || !key || key.length < 32) {
                alert("–ù—É–∂–µ–Ω —Ç–µ–∫—Å—Ç –∏ –∫–ª—é—á ‚â•32 —Å–∏–º–≤–æ–ª–æ–≤!");
                return;
            }
            
            try {
                const result = await qArmor.hybridEncrypt(text, key);
                document.getElementById('q-ciphertext').value = 
                    `QARMORv1|${result.params.prime}|${result.ciphertext}`;
            } catch (e) {
                alert("–û—à–∏–±–∫–∞: " + e.message);
            }
        }

        async function qDecrypt() {
            const input = document.getElementById('q-encrypted').value;
            const key = document.getElementById('q-decrypt-key').value;
            
            if (!input || !key) {
                alert("–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –∏ –∫–ª—é—á!");
                return;
            }
            
            try {
                const [header, primeHex, ciphertext] = input.split('|');
                if (header !== "QARMORv1") throw new Error("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç");
                
                qArmor.prime = BigInt("0x" + primeHex);
                const masterKey = await qArmor.sha512(key + "Q-ARMOR-SALT");
                const ntruKey = masterKey.slice(32);
                
                const data = new Uint8Array([...atob(ciphertext)].map(c => c.charCodeAt(0)));
                let state = qArmor.ntruTransform(data, ntruKey, false);
                
                // –û–±—Ä–∞—Ç–Ω–æ–µ AES-–ø–æ–¥–æ–±–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
                const aesKey = masterKey.slice(0, 64);
                for (let round = 15; round >= 0; round--) {
                    for (let i = state.length - 1; i >= 0; i--) {
                        state[i] ^= state[(i + round + 7) % state.length];
                        const keyPos = (i + round * 13) % aesKey.length;
                        state[i] = (state[i] - aesKey[keyPos] * (round + 1) + 256) % 256;
                    }
                }
                
                document.getElementById('q-decrypted').value = 
                    new TextDecoder().decode(state);
            } catch (e) {
                document.getElementById('q-decrypted').value = 
                    "–û–®–ò–ë–ö–ê: " + e.message;
            }
        }
    </script>
</body>
</html>
