<!DOCTYPE html>
<html>
<head>
    <title>Military-Grade Enigma Cracker</title>
    <style>
        body { font-family: monospace; background: #000; color: #0f0; margin: 0; padding: 20px; }
        #output { white-space: pre; font-size: 14px; line-height: 1.3; }
        .progress { background: #333; height: 20px; margin: 10px 0; }
        .progress-bar { background: #0f0; height: 100%; width: 0%; }
        button { background: #333; color: #0f0; border: 1px solid #0f0; padding: 5px 10px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>ENIGMA CRACKER v4.0</h1>
    <div>
        <button id="start">START ATTACK</button>
        <button id="stop" disabled>STOP</button>
    </div>
    <div class="progress"><div class="progress-bar" id="progress"></div></div>
    <div id="output">Ready to attack...</div>

<script>
// Английские частоты триграмм (сокращенная версия)
const ENGLISH_TRIGRAMS = {
    'THE':3.56,'AND':1.73,'ING':1.15,'ENT':0.76,'ION':0.76,
    'HER':0.73,'FOR':0.71,'THA':0.66,'NTH':0.66,'INT':0.64,
    'ERE':0.62,'TIO':0.61,'TER':0.61,'EST':0.60,'ERS':0.60
};

// Оптимизированный класс Enigma
class TurboEnigma {
    constructor(rotors, reflector, positions, rings, plugboard=[]) {
        this.rotors = rotors;
        this.reflector = reflector;
        this.positions = positions;
        this.rings = rings;
        this.plugboard = new Map(plugboard);
        this.reset();
    }

    reset() {
        this.pos1 = this.positions[0].charCodeAt(0) - 65;
        this.pos2 = this.positions[1].charCodeAt(0) - 65;
        this.pos3 = this.positions[2].charCodeAt(0) - 65;
    }

    encryptChar(c) {
        // Plugboard
        if(this.plugboard.has(c)) c = this.plugboard.get(c);

        // Step rotors
        this.stepRotors();

        // Forward pass
        let n = ((c.charCodeAt(0) - 65 + this.pos1 - this.rings[0] + 26) % 26);
        n = this.rotors[0].forward[n];
        n = ((n - this.pos1 + this.rings[0] + 26) % 26);

        n = ((n + this.pos2 - this.rings[1] + 26) % 26);
        n = this.rotors[1].forward[n];
        n = ((n - this.pos2 + this.rings[1] + 26) % 26);

        n = ((n + this.pos3 - this.rings[2] + 26) % 26);
        n = this.rotors[2].forward[n];
        n = ((n - this.pos3 + this.rings[2] + 26) % 26);

        // Reflector
        n = this.reflector[n];

        // Backward pass
        n = ((n + this.pos3 - this.rings[2] + 26) % 26);
        n = this.rotors[2].backward[n];
        n = ((n - this.pos3 + this.rings[2] + 26) % 26);

        n = ((n + this.pos2 - this.rings[1] + 26) % 26);
        n = this.rotors[1].backward[n];
        n = ((n - this.pos2 + this.rings[1] + 26) % 26);

        n = ((n + this.pos1 - this.rings[0] + 26) % 26);
        n = this.rotors[0].backward[n];
        n = ((n - this.pos1 + this.rings[0] + 26) % 26);

        // Plugboard
        const out = String.fromCharCode(65 + n);
        return this.plugboard.has(out) ? this.plugboard.get(out) : out;
    }

    stepRotors() {
        // Double stepping mechanism
        const notch2 = this.rotors[1].notch;
        const notch3 = this.rotors[2].notch;

        this.pos3 = (this.pos3 + 1) % 26;
        if(this.pos3 === notch3 || this.pos2 === notch2) {
            this.pos2 = (this.pos2 + 1) % 26;
            if(this.pos2 === notch2) {
                this.pos1 = (this.pos1 + 1) % 26;
            }
        }
    }

    encrypt(text) {
        let result = '';
        for(let i = 0; i < text.length; i++) {
            const c = text[i].toUpperCase();
            if(c >= 'A' && c <= 'Z') {
                result += this.encryptChar(c);
            }
        }
        return result;
    }
}

// Функция оценки осмысленности текста
function evaluateEnglish(text) {
    let score = 0;
    const cleanText = text.replace(/[^A-Z]/g, '');
    
    for(let i = 0; i < cleanText.length - 2; i++) {
        const trigram = cleanText.substr(i, 3);
        score += ENGLISH_TRIGRAMS[trigram] || -0.5;
    }
    
    // Дополнительные критерии
    const vowelRatio = (text.match(/[AEIOUY]/gi) || []).length / text.length;
    score += Math.abs(vowelRatio - 0.38) * 100; // 38% гласных в английском
    
    return score;
}

// Генератор конфигураций
function* configGenerator() {
    const rotors = [
        {id: 'I', forward: [4,10,12,5,11,6,3,16,21,25,13,19,14,22,24,7,23,20,18,15,0,8,1,17,2,9],
         backward: [20,22,24,6,0,3,5,15,21,25,1,4,2,10,12,19,7,23,18,11,17,8,13,16,14,9], notch: 16},
        {id: 'II', forward: [0,9,3,10,18,8,17,20,23,1,11,7,22,19,12,2,16,6,25,13,15,24,5,21,14,4],
         backward: [0,9,15,2,25,22,17,11,5,1,3,10,14,19,24,20,16,6,4,13,7,23,12,8,21,18], notch: 4},
        {id: 'III', forward: [1,3,5,7,9,11,2,15,17,19,23,21,25,13,24,4,8,22,6,0,10,12,20,18,16,14],
         backward: [19,0,6,1,15,2,18,3,16,4,20,5,21,13,25,7,24,8,23,9,22,11,17,10,14,12], notch: 21}
    ];

    const reflectors = [
        {id: 'B', wiring: [24,17,20,7,16,18,11,3,15,23,13,6,14,10,12,8,4,1,5,25,2,22,21,9,0,19]},
        {id: 'C', wiring: [5,21,15,9,8,0,14,24,4,3,17,25,23,22,6,2,19,10,20,16,18,1,13,12,7,11]}
    ];

    // Перебор всех комбинаций
    for(let r1 = 0; r1 < rotors.length; r1++) {
        for(let r2 = 0; r2 < rotors.length; r2++) {
            if(r2 === r1) continue;
            for(let r3 = 0; r3 < rotors.length; r3++) {
                if(r3 === r1 || r3 === r2) continue;
                for(let ref = 0; ref < reflectors.length; ref++) {
                    for(let p1 = 0; p1 < 26; p1++) {
                        for(let p2 = 0; p2 < 26; p2++) {
                            for(let p3 = 0; p3 < 26; p3++) {
                                yield {
                                    rotors: [rotors[r1], rotors[r2], rotors[r3]],
                                    reflector: reflectors[ref],
                                    positions: [
                                        String.fromCharCode(65 + p1),
                                        String.fromCharCode(65 + p2),
                                        String.fromCharCode(65 + p3)
                                    ],
                                    rings: ['A','A','A'],
                                    plugboard: []
                                };
                            }
                        }
                    }
                }
            }
        }
    }
}

// Основной процесс взлома
class EnigmaCracker {
    constructor() {
        this.isRunning = false;
        this.generator = null;
        this.bestScore = -Infinity;
        this.bestResult = null;
        this.configsTested = 0;
        this.startTime = 0;
    }

    start(ciphertext, updateCallback) {
        this.isRunning = true;
        this.generator = configGenerator();
        this.bestScore = -Infinity;
        this.configsTested = 0;
        this.startTime = Date.now();

        const processBatch = () => {
            if(!this.isRunning) return;

            // Обрабатываем партию конфигураций
            for(let i = 0; i < 1000 && this.isRunning; i++) {
                const config = this.generator.next().value;
                if(!config) {
                    this.isRunning = false;
                    updateCallback({done: true});
                    return;
                }

                const enigma = new TurboEnigma(
                    config.rotors,
                    config.reflector.wiring,
                    config.positions,
                    config.rings,
                    config.plugboard
                );

                const decrypted = enigma.encrypt(ciphertext);
                const score = evaluateEnglish(decrypted);

                this.configsTested++;

                if(score > this.bestScore) {
                    this.bestScore = score;
                    this.bestResult = {
                        config,
                        decrypted,
                        score
                    };

                    updateCallback({
                        best: this.bestResult,
                        tested: this.configsTested,
                        time: (Date.now() - this.startTime) / 1000
                    });
                }
            }

            if(this.isRunning) {
                setTimeout(processBatch, 0);
            }
        };

        processBatch();
    }

    stop() {
        this.isRunning = false;
    }
}

// UI взаимодействие
document.addEventListener('DOMContentLoaded', () => {
    const output = document.getElementById('output');
    const progress = document.getElementById('progress');
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');

    const ciphertext = "OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR";
    const cracker = new EnigmaCracker();

    startBtn.addEventListener('click', () => {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        output.textContent = "Starting attack...";

        cracker.start(ciphertext, (result) => {
            if(result.done) {
                output.textContent += "\n\nATTACK COMPLETE!";
                startBtn.disabled = false;
                stopBtn.disabled = true;
                return;
            }

            if(result.best) {
                output.textContent = 
                    `Best so far (${result.tested.toLocaleString()} tested, ${result.time.toFixed(1)}s):\n` +
                    `Score: ${result.best.score.toFixed(2)}\n` +
                    `Rotors: ${result.best.config.rotors.map(r => r.id).join(', ')} ` +
                    `at ${result.best.config.positions.join(', ')}\n` +
                    `Reflector: ${result.best.config.reflector.id}\n` +
                    `Decrypted: ${result.best.decrypted.substr(0, 50)}...\n\n` +
                    `Testing speed: ${Math.floor(result.tested/result.time)} configs/sec`;
            }

            progress.style.width = `${Math.min(100, result.tested / 1000000 * 100)}%`;
        });
    });

    stopBtn.addEventListener('click', () => {
        cracker.stop();
        startBtn.disabled = false;
        stopBtn.disabled = true;
        output.textContent += "\nAttack stopped by user";
    });
});
</script>
</body>
</html>
