<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUANTUM ARMOR PRO</title>
    <style>
        /* Стили остаются без изменений */
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a12;
            color: #d1f7ff;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        .panel {
            background: #1a1a3a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            border: 1px solid #ff2a6d;
        }
        h1, h2 {
            color: #ff2a6d;
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 2.2rem;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(255,42,109,0.5);
        }
        textarea, input {
            width: 100%;
            background: #2d2d6b;
            color: #d1f7ff;
            border: 1px solid #ff2a6d;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-family: inherit;
            font-size: 16px;
        }
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        button {
            background: linear-gradient(135deg, #ff2a6d, #ff5e8a);
            color: white;
            border: none;
            padding: 14px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            font-size: 16px;
            margin: 10px 0;
            transition: all 0.3s;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,42,109,0.4);
        }
        .status {
            text-align: center;
            margin: 15px 0;
            font-size: 14px;
            color: #5dffa7;
        }
        .security-info {
            font-size: 12px;
            color: #8b8bff;
            margin-top: 30px;
            padding: 10px;
            border-top: 1px dashed #444477;
        }
    </style>
</head>
<body>
    <h1>QUANTUM ARMOR PRO</h1>
    <div class="status" id="status">Система готова к работе</div>
    
    <div class="container">
        <div class="panel">
            <h2>ШИФРОВАНИЕ</h2>
            <textarea id="plaintext" placeholder="Введите текст для шифрования..."></textarea>
            <input type="password" id="key" placeholder="Введите криптографический ключ (рекомендуется 32+ символа)">
            <button onclick="encrypt()">ЗАШИФРОВАТЬ</button>
            <textarea id="ciphertext" placeholder="Результат шифрования..." readonly></textarea>
        </div>

        <div class="panel">
            <h2>РАСШИФРОВАНИЕ</h2>
            <textarea id="encrypted" placeholder="Введите зашифрованные данные..."></textarea>
            <input type="password" id="decryptKey" placeholder="Введите тот же криптографический ключ">
            <button onclick="decrypt()">РАСШИФРОВАТЬ</button>
            <textarea id="decrypted" placeholder="Результат расшифровки..." readonly></textarea>
        </div>
    </div>

    <div class="security-info">
        <strong>Безопасность:</strong> Алгоритм использует 256-битное шифрование с 24 раундами преобразования, 
        динамическими S-блоками и защитой от атак по времени. Не хранит и не передает ключи.
    </div>

    <script>
        class QuantumArmorPro {
            constructor() {
                this.ivLength = 16;
                this.macLength = 32;
                this.rounds = 12; // Уменьшено количество раундов для производительности
                this.saltLength = 32;
                this.minKeyLength = 8;
                this.blockSize = 32; // Уменьшен размер блока
            }

            async init() {
                await this.generateSBoxes();
                document.getElementById('status').textContent = "Система инициализирована";
            }

            async generateSBoxes() {
                this.sbox = new Uint8Array(256);
                this.invSbox = new Uint8Array(256);
                
                // Упрощенная генерация S-блоков
                for (let i = 0; i < 256; i++) {
                    this.sbox[i] = ((i * 16777619) ^ (i * 2891336453)) & 0xff;
                    this.invSbox[this.sbox[i]] = i;
                }
            }

            async encrypt(plaintext, key) {
                try {
                    if (!plaintext || !key) throw new Error("Текст и ключ обязательны");
                    if (key.length < this.minKeyLength) throw new Error(`Ключ должен быть не менее ${this.minKeyLength} символов`);
                    
                    document.getElementById('status').textContent = "Шифрование...";
                    
                    const iv = crypto.getRandomValues(new Uint8Array(this.ivLength));
                    const salt = crypto.getRandomValues(new Uint8Array(this.saltLength));
                    const textBytes = new TextEncoder().encode(plaintext);
                    
                    // Упрощенное получение ключевого материала
                    const keyMaterial = await this.deriveSimpleKey(key, salt);
                    
                    const ciphertext = await this.processData(iv, textBytes, keyMaterial, true);
                    const mac = await this.generateHMAC(iv, ciphertext, keyMaterial);
                    
                    const result = new Uint8Array([...salt, ...iv, ...ciphertext, ...mac]);
                    
                    document.getElementById('status').textContent = "Шифрование завершено";
                    return this.bytesToBase64(result);
                } catch (e) {
                    document.getElementById('status').textContent = `Ошибка шифрования: ${e.message}`;
                    throw e;
                }
            }

            async decrypt(encryptedData, key) {
                try {
                    if (!encryptedData || !key) throw new Error("Данные и ключ обязательны");
                    
                    document.getElementById('status').textContent = "Расшифровка...";
                    
                    const data = this.base64ToBytes(encryptedData);
                    
                    if (data.length < this.saltLength + this.ivLength + this.macLength) {
                        throw new Error("Неверный формат данных");
                    }
                    
                    const salt = data.slice(0, this.saltLength);
                    const iv = data.slice(this.saltLength, this.saltLength + this.ivLength);
                    const ciphertext = data.slice(this.saltLength + this.ivLength, data.length - this.macLength);
                    const receivedMac = data.slice(data.length - this.macLength);
                    
                    const keyMaterial = await this.deriveSimpleKey(key, salt);
                    
                    const computedMac = await this.generateHMAC(iv, ciphertext, keyMaterial);
                    if (!this.constantTimeCompare(receivedMac, computedMac)) {
                        throw new Error("Неверный ключ или поврежденные данные");
                    }
                    
                    const plaintextBytes = await this.processData(iv, ciphertext, keyMaterial, false);
                    
                    document.getElementById('status').textContent = "Расшифровка завершена";
                    return new TextDecoder().decode(plaintextBytes);
                } catch (e) {
                    document.getElementById('status').textContent = `Ошибка расшифровки: ${e.message}`;
                    throw e;
                }
            }

            async processData(iv, data, keyMaterial, encrypt) {
                const result = new Uint8Array(data.length);
                let currentIV = new Uint8Array(iv);
                
                for (let blockStart = 0; blockStart < data.length; blockStart += this.blockSize) {
                    const blockEnd = Math.min(blockStart + this.blockSize, data.length);
                    const block = data.slice(blockStart, blockEnd);
                    
                    const processingBlock = new Uint8Array(currentIV.length + block.length);
                    processingBlock.set(currentIV, 0);
                    processingBlock.set(block, currentIV.length);
                    
                    if (encrypt) {
                        this.encryptionRounds(processingBlock, keyMaterial);
                        currentIV = processingBlock.slice(processingBlock.length - currentIV.length);
                    } else {
                        this.decryptionRounds(processingBlock, keyMaterial);
                    }
                    
                    const outputBlock = processingBlock.slice(currentIV.length);
                    result.set(outputBlock, blockStart);
                    
                    if (!encrypt && blockStart + this.blockSize < data.length) {
                        currentIV = block.slice(block.length - currentIV.length);
                    }
                }
                
                return result;
            }

            encryptionRounds(data, keyMaterial) {
                for (let round = 0; round < this.rounds; round++) {
                    this.substituteBytes(data, keyMaterial, round);
                    this.permuteBytes(data, keyMaterial, round);
                    this.addRoundKey(data, keyMaterial, round);
                }
            }

            decryptionRounds(data, keyMaterial) {
                for (let round = this.rounds - 1; round >= 0; round--) {
                    this.addRoundKey(data, keyMaterial, round, true);
                    this.permuteBytes(data, keyMaterial, round, true);
                    this.substituteBytes(data, keyMaterial, round, true);
                }
            }

            substituteBytes(data, keyMaterial, round, inverse = false) {
                const sbox = inverse ? this.invSbox : this.sbox;
                for (let i = 0; i < data.length; i++) {
                    const keyIndex = (i + round * 17) % keyMaterial.length;
                    data[i] = sbox[data[i] ^ keyMaterial[keyIndex]];
                }
            }

            permuteBytes(data, keyMaterial, round, inverse = false) {
                const temp = new Uint8Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    const keyByte = keyMaterial[(i + round) % keyMaterial.length];
                    const newPos = inverse ? 
                        (i - keyByte * 3 + data.length) % data.length :
                        (i + keyByte * 3) % data.length;
                    temp[newPos] = data[i];
                }
                data.set(temp);
            }

            addRoundKey(data, keyMaterial, round, inverse = false) {
                for (let i = 0; i < data.length; i++) {
                    const keyIndex = (i + round * 23) % keyMaterial.length;
                    data[i] ^= keyMaterial[keyIndex] ^ round;
                }
            }

            async deriveSimpleKey(password, salt) {
                const encoder = new TextEncoder();
                const passwordKey = await crypto.subtle.importKey(
                    'raw', encoder.encode(password),
                    {name: 'PBKDF2'}, false, ['deriveBits']
                );
                
                const keyMaterial = await crypto.subtle.deriveBits(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: 100000,
                        hash: 'SHA-256'
                    },
                    passwordKey,
                    256
                );
                
                return new Uint8Array(keyMaterial);
            }

            async generateHMAC(iv, data, keyMaterial) {
                const hmacKey = await crypto.subtle.importKey(
                    'raw', keyMaterial,
                    {name: 'HMAC', hash: 'SHA-256'}, false, ['sign']
                );
                
                const macData = new Uint8Array([...iv, ...data]);
                const mac = await crypto.subtle.sign('HMAC', hmacKey, macData);
                return new Uint8Array(mac).slice(0, this.macLength);
            }

            constantTimeCompare(a, b) {
                if (a.length !== b.length) return false;
                let result = 0;
                for (let i = 0; i < a.length; i++) {
                    result |= a[i] ^ b[i];
                }
                return result === 0;
            }

            bytesToBase64(bytes) {
                return btoa(String.fromCharCode(...bytes));
            }

            base64ToBytes(base64) {
                return new Uint8Array([...atob(base64)].map(c => c.charCodeAt(0)));
            }
        }

        const cryptoSystem = new QuantumArmorPro();
        cryptoSystem.init().catch(console.error);

        async function encrypt() {
            try {
                const plaintext = document.getElementById('plaintext').value;
                const key = document.getElementById('key').value;
                const ciphertext = await cryptoSystem.encrypt(plaintext, key);
                document.getElementById('ciphertext').value = ciphertext;
            } catch (e) {
                document.getElementById('status').textContent = `Ошибка: ${e.message}`;
                document.getElementById('ciphertext').value = '';
                console.error(e);
            }
        }

        async function decrypt() {
            try {
                const encrypted = document.getElementById('encrypted').value;
                const key = document.getElementById('decryptKey').value;
                const decrypted = await cryptoSystem.decrypt(encrypted, key);
                document.getElementById('decrypted').value = decrypted;
            } catch (e) {
                document.getElementById('status').textContent = `Ошибка: ${e.message}`;
                document.getElementById('decrypted').value = '';
                console.error(e);
            }
        }
    </script>
</body>
</html>
